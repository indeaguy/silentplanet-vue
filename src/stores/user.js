import { defineStore } from 'pinia'
import { supabase } from '../lib/supabaseClient'

export const useUserStore = defineStore('user', {
  state: () => ({
    user: null,
    error: null,
    phraseHistory: {
      entries: [], // Complete input strings
      phrases: {}, // Individual phrases by position
      lastUsed: {} // Timestamp of last use for each phrase
    }
  }),
  actions: {
    async signIn(email, password) {
      try {
        const { data, error } = await supabase.auth.signInWithPassword({
          email,
          password
        })
        if (error) throw error
        this.user = data.user
        this.error = null
      } catch (error) {
        this.error = error.message
        throw error
      }
    },
    async signUp(email, password) {
      try {
        const { data, error } = await supabase.auth.signUp({
          email,
          password
        })
        if (error) throw error
        this.user = data.user
        this.error = null
      } catch (error) {
        this.error = error.message
        throw error
      }
    },
    async signOut() {
      try {
        const { error } = await supabase.auth.signOut()
        if (error) throw error
        this.user = null
        this.error = null
      } catch (error) {
        this.error = error.message
        throw error
      }
    },
    async addPhraseEntry(fullString, phraseArray) {
      try {
        // Store the complete entry
        this.phraseHistory.entries.push(fullString)

        // Store individual phrases by their position
        phraseArray.forEach((phrase, index) => {
          if (!this.phraseHistory.phrases[index]) {
            this.phraseHistory.phrases[index] = new Set()
          }
          this.phraseHistory.phrases[index].add(phrase)
          this.phraseHistory.lastUsed[`${index}-${phrase}`] = Date.now()
        })

        // Optionally persist to Supabase here
        if (this.user) {
          // await supabase.from('phrase_history').insert(...)
        }
      } catch (error) {
        this.error = error.message
        throw error
      }
    },
    getMostRecentPhrases(position, limit = 5) {
      const phrases = Array.from(this.phraseHistory.phrases[position] || [])
      return phrases
        .sort((a, b) => {
          return (this.phraseHistory.lastUsed[`${position}-${b}`] || 0) -
                 (this.phraseHistory.lastUsed[`${position}-${a}`] || 0)
        })
        .slice(0, limit)
    }
  }
}) 